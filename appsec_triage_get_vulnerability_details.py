from jira_utility.jira_api_actions import JiraApiActions
from checkmarx_utility.cx_api_actions import CxApiActions
from checkmarx_utility.cx_token_manager import AccessTokenManager
from utils.helper_functions import HelperFunctions

from utils.logger import Logger

import os
import sys
import json

def _set_package_and_version(package_version: str) -> tuple[str, str]:
    """
    Splits a package string into name and version.
    Example: 'multer 1.4.5-lts.2' -> ('multer', '1.4.5-lts.2')
    """
    name, version = package_version.rsplit(" ", 1)
    return name, version

def _assemble_sast_scan_url(cx_tenant_url: str, scan_data: dict, vuln_id: str) -> str:
    """
    Assembles the SAST scan result URL.
    """
    project_id = scan_data.get('project_id')
    scan_id = scan_data.get('scan_id')
    branch = scan_data.get('branch')
    return f"https://{cx_tenant_url}/results/{scan_id}/{project_id}/sast?result-id={vuln_id}&branch={branch}"

def _assemble_csec_image_remediations(image_remediation: dict) -> dict:
    """
    Assemble CSEC image remediation details
    """
    return {
        "image_id": image_remediation.get('imageId'),
        "minor_recommended_images": image_remediation.get('minorRecommendedImages'),
        "major_recommended_images": image_remediation.get('majorRecommendedImages'),
        "alternative_recommended_images": image_remediation.get('alternativeRecommendedImages'),
        "next_recommended_images": image_remediation.get('nextRecommendedImages'),
        "not_outdated_recommended_images": image_remediation.get('notOutdatedRecommendedImages')
    }

def _assemble_sast_attack_vector_url(github_repo_url: str, params: dict) -> str:
    """
    Assemble a GitHub URL pointing to a specific line in a file.
    Example: 'https://github.com/test-devsecops/devsecops/blob/release/express-vulnerable-app/app.js#L55'
    """
    branch = params.get('branch')
    file_path = params.get('file_path')
    line_number = params.get('line_number')
    return f"{github_repo_url}/blob/{branch}{file_path}#L{line_number}"

def _set_sca_package_details(base_details: dict, vulnerability_data: dict) -> dict:
    """
    Populates SCA package details into the base details dictionary.
    """
    items = vulnerability_data.get("data", {}).get("vulnerabilitiesRisksByScanId", {}).get("items", [])
    package_list = []

    for item in items:
        # EPSS score
        epss_score = ""
        epss_data = item.get("epssData", {})
        raw_epss = epss_data.get("epss")
        if raw_epss is not None:
            epss_score = round(raw_epss * 100, 2)

        # CVSS3 info
        cvss3 = item.get("cvss3") or {}
        attack_vector = cvss3.get("attackVector", "")
        attack_complexity = cvss3.get("attackComplexity", "")
        confidentiality_impact = cvss3.get("confidentiality", "")
        availability_impact = cvss3.get("availability", "")

        # Exploitable paths
        exploitable_path = item.get("exploitablePath", [])

        # Package info
        package_info = item.get("packageInfo", {})
        package_name = package_info.get("name", "")
        package_version = package_info.get("version", "")
        package_repo = package_info.get("packageRepository", "")

        package_entry = {
            "cve_number": item.get("cve"),
            "cvss_score": item.get("score"),
            "cve_description": {
                "description": item.get("description"),
                "references": item.get("references"),
                "attack_vector": attack_vector,
                "attack_complexity": attack_complexity,
                "confidentiality_impact": confidentiality_impact,
                "availability_impact": availability_impact,
                "version_upgrade_recommendation": item.get("vulnerabilityFixResolutionText"),
                "exploitable_path": exploitable_path
            },
            "epss_score": epss_score,
            "package_name": package_name,
            "package_version": package_version,
            "package_repository": package_repo,
            "justification": "",
            "triage_status": ""
        }
        package_list.append(package_entry)

    base_details["package"] = package_list
    return base_details

def _set_csec_package_details(base_details: dict, image_id : str, package_data: dict, cve_details: list, image_remediations: dict) -> dict:
    """
    Populates CSEC package details into the base details dictionary.
    """
    package = package_data[0]

    package_entry = {
        "image_name": image_id,
        "package_name": package.get('packageId'),
        "package_version": package.get('packageVersion'),
        "cves": [],
        "image_remediations": image_remediations
    }

    for cve in cve_details:

        cvss = cve.get("cvss3", {}) or cve.get("cvss2", {}) or cve.get("cvss4", {})
        cvss_score = cvss.get('baseScore', 'None')
        cvss_attack_vector = cvss.get('attackVector', 'None')
        cvss_attack_complexity = cvss.get('attackComplexity', 'None')
        cvss_confidentiality = cvss.get('confidentiality', 'None')
        cvss_availability = cvss.get('availability', 'None')

        epss_score = ""
        raw_epss = cve.get("epss", {}).get('percentile')
        if raw_epss is not None:
            epss_score = round(raw_epss * 100, 2)

        cve_entry = {
            "cve_number": cve.get('cveName'),
            "cvss_score": cvss_score,
            "cve_description": {
                "description": cve.get('description'),
                "notes": cve.get('note', 'Empty'),
                "references": cve.get('references', 'None'),
                "attack_vector": cvss_attack_vector,
                "attack_complexity": cvss_attack_complexity,
                "confidentiality_impact": cvss_confidentiality,
                "availability_impact": cvss_availability,
                "vulnerable_path": cve.get('vulnerablePaths', 'Empty'),
                "recommendations": []
            },
            "epss_score": epss_score,
            "justification": "",
            "triage_status": ""
        }

        package_entry['cves'].append(cve_entry)

    base_details["package"] = package_entry
    return base_details

def _set_sast_vulnerabilities_details(
    sast_result_url: str,
    sast_results: dict,
    query_data: list,
    vuln_id: str
) -> dict:
    """
    Populates SAST vulnerability details for a single vulnerability.
    """
    if not query_data:
        return {}

    query = query_data[0]
    vulnerability_entry = {
        "vulnerability_id": vuln_id,
        "repository_url": "",
        "vulnerability_description": {
            "description": query.get("resultDescription"),
            "sast_result_url": sast_result_url,
            "severity": sast_results.get("severity"),
            "state": sast_results.get("state"),
            "status": sast_results.get("status"),
            "attack_vector": sast_results.get("attack_vector"),
            "source": query.get("querySource"),
            "source-path": query.get("querySourcePath"),
            "risk": query.get("risk"),
            "cause": query.get("cause"),
            "recommendations": query.get("generalRecommendations")
        },
        "vulnerability_name": query.get("queryName"),
        "justification": "",
        "triage_status": ""
    }
    return vulnerability_entry

def main():
    """
    Main entry point for vulnerability details extraction.
    """
    # Dummy input for testing
    TEST_SCAN_ID = "0b14a69a-a6db-470c-ae75-190a45446859"
    TEST_VULN_IDS = ["ysTAGGDe/mRAJty/2BEXEUhNeTo=", "viecwVGMKasENDn+zTf03PNojkg="]
    TEST_PACKAGE_NAME = "libc-bin:2.36-9+deb12u10"
    SCAN_TYPE_SAST = "SAST"
    SCAN_TYPE_SCA = "SCA"
    SCAN_TYPE_CSEC = "CSEC"
    SCAN_TYPE_DAST = "DAST"

    scan_type = SCAN_TYPE_CSEC  # Change as needed for testing

    log = Logger("appsec_triage")
    access_token_manager = AccessTokenManager(logger=log)
    access_token = access_token_manager.get_valid_token()
    cx_api_actions = CxApiActions(access_token=access_token, logger=log)
    helper = HelperFunctions()

    scan_details = cx_api_actions.get_scan_details(TEST_SCAN_ID)
    if scan_details is None:
        log.error(f"Scan ID {TEST_SCAN_ID} is empty or does not exist")
        return

    project_name = scan_details.get('projectName')
    project_id = scan_details.get('projectId')
    branch = scan_details.get('branch')
    scan_id = scan_details.get('id')
    tenant_url = cx_api_actions.get_tenant_url()
    repo_url = helper.get_nested(scan_details, ['metadata', 'Handler', 'GitHandler', 'repo_url'])
    lbu_name = helper.get_lbu_name_simple(project_name)

    log.info(f"Project Name: {project_name}")
    log.info(f"Scan ID: {scan_id}")
    log.info(f"Branch: {branch}")
    log.info(f"LBU: {lbu_name}")

    base_result_details = {
        "lbu": lbu_name,
        "project_name": project_name,
        "branch_name": branch,
        "scan_id": scan_id,
        "scan_engine": scan_type,
        "repo_url": repo_url,
        "vulnerability": [],
        "package": []
    }

    if scan_type == SCAN_TYPE_SAST:

        log.info(f"Scan Type: {scan_type}")

        for vuln_id in TEST_VULN_IDS:

            selected_scan_details = {
                "project_id": project_id,
                "scan_id": scan_id,
                "branch": branch
            }

            sast_result_url = _assemble_sast_scan_url(tenant_url, selected_scan_details, vuln_id)
            sast = cx_api_actions.get_sast_results(scan_id, vuln_id)
            sast_results = sast.get("results")

            if not sast_results:
                log.warning(f"No SAST results for vulnerability ID {vuln_id}")
                continue

            query_id = sast_results[0].get("queryID")

            query_details = cx_api_actions.get_query_descriptions(scan_id, query_id)

            selected_sast_result = {
                "severity": sast_results[0].get("severity"),
                "state": sast_results[0].get("state"),
                "status": sast_results[0].get("status"),
                "attack_vector": []
            }

            for node in sast_results[0].get("nodes", []):
                selected_vector_details = {
                    'branch': branch,
                    'file_path': node.get("fileName"),
                    'line_number': node.get("line"),
                    'column': node.get("column")
                }

                vector_url = _assemble_sast_attack_vector_url(repo_url, selected_vector_details)
                node_vector = {
                    "name": node.get("name"),
                    "vector_url": vector_url,
                    "method": node.get("method"),
                }

                selected_sast_result['attack_vector'].append(node_vector)

            sast_vuln_info = _set_sast_vulnerabilities_details(sast_result_url, selected_sast_result, query_details, vuln_id)

            base_result_details["vulnerability"].append(sast_vuln_info)

        print(json.dumps(base_result_details, indent=4))

    elif scan_type == SCAN_TYPE_SCA:

        log.info(f"Scan Type: {scan_type}")

        package, version = _set_package_and_version(TEST_PACKAGE_NAME)

        sca = cx_api_actions.get_sca_vulnerability_details_graphql(scan_id, project_id, package, version)
        sca_vuln_info = _set_sca_package_details(base_result_details, sca)
        
        print(json.dumps(sca_vuln_info, indent=4))

    elif scan_type == SCAN_TYPE_CSEC:
        log.info(f"Scan Type: {scan_type}")
        
        images = cx_api_actions.get_image_id_graphql(scan_id, project_id)
        image = helper.get_nested(images, ['data', 'images', 'items'])
        image_id = image[0].get('imageId')

        # Get Image Vulnerabilities using Package Name
        csec_vuln_details = cx_api_actions.get_csec_vulnerability_details_graphql(scan_id, project_id, image_id, TEST_PACKAGE_NAME)
        image_vuln_details = helper.get_nested(csec_vuln_details, ['data', 'imagesVulnerabilities', 'items'])
        risk_list = helper.get_nested(image_vuln_details[0], ['aggregatedRisks', 'risksList'])

        # Get CVE Details
        cve_list = []
        for risk in risk_list:
            cve_id = risk.get("cve")
            cve_details = cx_api_actions.get_vulnerability_details(cve_id)
            cve_list.append(cve_details)

        # Get remediations/recommendations
        layers_details = cx_api_actions.get_csec_image_layer_graphql(scan_id, project_id, image_id)
        layer_images = helper.get_nested(layers_details,  ['data', 'imageLayers', 'fromImages'])

        image_layers = [layer_image.get('imageName') for layer_image in layer_images] + [image_id]

        compiled_image_remediations = []
        for image_layer in image_layers:
            image_remediations = cx_api_actions.get_csec_image_remediations_graphql(scan_id, project_id, image_layer)
            image_remediation = helper.get_nested(image_remediations, ['data', 'imageRemediations'])
            formatted_image_remediation = _assemble_csec_image_remediations(image_remediation)
            compiled_image_remediations.append(formatted_image_remediation)

        csec_vuln_info = _set_csec_package_details(base_result_details, image_id, image_vuln_details, cve_list, compiled_image_remediations)

        print(json.dumps(csec_vuln_info, indent=4))

    elif scan_type == SCAN_TYPE_DAST:
        log.info(f"Scan Type: {scan_type}")
        # Implement DAST logic here if needed

    else:
        log.warning(f"The {scan_type} Scan type is not supported by this workflow automation.")

if __name__ == "__main__":
    main()
