from jira_utility.jira_api_actions import JiraApiActions
from checkmarx_utility.cx_api_actions import CxApiActions
from checkmarx_utility.cx_token_manager import AccessTokenManager
from utils.helper_functions import HelperFunctions

from utils.logger import Logger
from urllib.parse import urlparse, parse_qs

import os
import sys
import json

def _parse_package_csec(pkg: str) -> str:
    """
    Changes csec packages to add colon if user input 'name:package' as 'name package'
    Example: 'sqlite3 3.40.1-2+deb12u1' -> sqlite3:3.40.1-2+deb12u1
    """
    pkg = pkg.strip()
    
    if ":" in pkg:
        return pkg
    
    parts = pkg.split()
    if len(parts) == 2:
        return f"{parts[0]}:{parts[1]}"
    
    return pkg

def _set_package_and_version(package_version: str) -> tuple[str, str]:
    """
    Splits a package string into name and version for SCA.
    Example: 'multer 1.4.5-lts.2' -> ('multer', '1.4.5-lts.2')
    """
    name, version = package_version.rsplit(" ", 1)
    return name, version

def _assemble_sast_scan_url(cx_tenant_url: str, scan_data: dict, vuln_id: str) -> str:
    """
    Assembles the SAST scan result URL.
    """
    project_id = scan_data.get('project_id')
    scan_id = scan_data.get('scan_id')
    branch = scan_data.get('branch')
    return f"https://{cx_tenant_url}/results/{scan_id}/{project_id}/sast?result-id={vuln_id}&branch={branch}"

def _assemble_csec_image_remediations(image_remediation: dict) -> dict:
    """
    Assemble CSEC image remediation details
    """
    return {
        "image_id": image_remediation.get('imageId'),
        "minor_recommended_images": image_remediation.get('minorRecommendedImages'),
        "major_recommended_images": image_remediation.get('majorRecommendedImages'),
        "alternative_recommended_images": image_remediation.get('alternativeRecommendedImages'),
        "next_recommended_images": image_remediation.get('nextRecommendedImages'),
        "not_outdated_recommended_images": image_remediation.get('notOutdatedRecommendedImages')
    }

def _assemble_sast_attack_vector_url(github_repo_url: str, params: dict) -> str:
    """
    Assemble a GitHub URL pointing to a specific line in a file.
    Example: 'https://github.com/test-devsecops/devsecops/blob/release/express-vulnerable-app/app.js#L55'
    """
    branch = params.get('branch')
    file_path = params.get('file_path')
    line_number = params.get('line_number')
    return f"{github_repo_url}/blob/{branch}{file_path}#L{line_number}"

def _set_sca_package_details(base_details: dict, vulnerability_data: dict) -> dict:
    """
    Populates SCA package details into the base details dictionary.
    """
    if vulnerability_data is None or "errors" in vulnerability_data:
        raise TypeError("SCA data is None (insufficient data)")
    items = vulnerability_data.get("data", {}).get("vulnerabilitiesRisksByScanId", {}).get("items", [])
    package_list = []

    for item in items:
        # EPSS score
        epss_score = ""
        epss_data = item.get("epssData", {})
        raw_epss = epss_data.get("epss")
        if raw_epss is not None:
            epss_score = round(raw_epss * 100, 2)

        # CVSS3 info
        cvss3 = item.get("cvss3") or {}
        attack_vector = cvss3.get("attackVector", "")
        attack_complexity = cvss3.get("attackComplexity", "")
        confidentiality_impact = cvss3.get("confidentiality", "")
        availability_impact = cvss3.get("availability", "")

        # Exploitable paths
        exploitable_path = item.get("exploitablePath", [])

        # Package info
        package_info = item.get("packageInfo", {})
        package_name = package_info.get("name", "")
        package_version = package_info.get("version", "")
        package_repo = package_info.get("packageRepository", "")

        package_entry = {
            "cve_number": item.get("cve"),
            "cvss_score": item.get("score"),
            "cve_description": {
                "description": item.get("description"),
                "references": item.get("references"),
                "attack_vector": attack_vector,
                "attack_complexity": attack_complexity,
                "confidentiality_impact": confidentiality_impact,
                "availability_impact": availability_impact,
                "version_upgrade_recommendation": item.get("vulnerabilityFixResolutionText"),
                "exploitable_path": exploitable_path
            },
            "epss_score": epss_score,
            "package_name": package_name,
            "package_version": package_version,
            "package_repository": package_repo,
            "justification": "",
            "triage_status": ""
        }
        package_list.append(package_entry)

    base_details["package"] = package_list
    return base_details

def _set_csec_package_details(base_details: dict, image_id : str, package_data: dict, cve_details: list, image_remediations: dict) -> dict:
    """
    Populates CSEC package details into the base details dictionary.
    """
    package = package_data[0]

    package_entry = {
        "image_name": image_id,
        "package_name": package.get('packageId'),
        "package_version": package.get('packageVersion'),
        "cves": [],
        "image_remediations": image_remediations
    }

    for cve in cve_details:

        cvss = cve.get("cvss3", {}) or cve.get("cvss2", {}) or cve.get("cvss4", {})
        cvss_score = cvss.get('baseScore', 'None')
        cvss_attack_vector = cvss.get('attackVector', 'None')
        cvss_attack_complexity = cvss.get('attackComplexity', 'None')
        cvss_confidentiality = cvss.get('confidentiality', 'None')
        cvss_availability = cvss.get('availability', 'None')

        epss_score = ""
        raw_epss = cve.get("epss", {}).get('percentile')
        if raw_epss is not None:
            epss_score = round(raw_epss * 100, 2)

        cve_entry = {
            "cve_number": cve.get('cveName'),
            "cvss_score": cvss_score,
            "cve_description": {
                "description": cve.get('description'),
                "notes": cve.get('note', 'Empty'),
                "references": cve.get('references', 'None'),
                "attack_vector": cvss_attack_vector,
                "attack_complexity": cvss_attack_complexity,
                "confidentiality_impact": cvss_confidentiality,
                "availability_impact": cvss_availability,
                "vulnerable_path": cve.get('vulnerablePaths', 'Empty'),
                "recommendations": []
            },
            "epss_score": epss_score,
            "justification": "",
            "triage_status": ""
        }

        package_entry['cves'].append(cve_entry)

    base_details["package"] = package_entry
    return base_details

def _set_sast_vulnerabilities_details(base_result_details, sast_result_url: str, sast_results: dict, query_data: list, vuln_id: str) -> dict:
    """
    Populates SAST vulnerability details for a single vulnerability.
    """
    if not query_data:
        return {}

    query = query_data[0]
    vulnerability_entry = {
        "vulnerability_id": vuln_id,
        "repository_url": "",
        "vulnerability_description": {
            "description": query.get("resultDescription"),
            "sast_result_url": sast_result_url,
            "severity": sast_results.get("severity"),
            "state": sast_results.get("state"),
            "status": sast_results.get("status"),
            "attack_vector": sast_results.get("attack_vector"),
            "source": query.get("querySource"),
            "source-path": query.get("querySourcePath"),
            "risk": query.get("risk"),
            "cause": query.get("cause"),
            "recommendations": query.get("generalRecommendations")
        },
        "vulnerability_name": query.get("queryName"),
        "justification": "",
        "triage_status": ""
    }

    base_result_details["vulnerability"].append(vulnerability_entry)
    return base_result_details

def _set_dast_finding_details(base_details: dict, dast_results: list, result_urls : list) -> dict:
    """
    Populates CSEC package details into the base details dictionary.
    """
    findings = []
    i = 0
    for finding in dast_results:
        finding_entry = {
            "result_url": result_urls[i],
            "vulnerability_url": finding.get('url'),
            "result_category": finding.get('name'),
            "result_description": {
                "description": finding.get('description'),
                "solution": finding.get('solution'),
                "params": finding.get('params'),
                "path": finding.get('path'),
                "method": finding.get('method'),
                "attack": finding.get('attack'),
                "evidence": finding.get('evidence'),
                "severity": finding.get('severity'),
            },
            "justification": "",
            "triage_status": finding.get('state')
        }
        findings.append(finding_entry)
        i += 1 

    base_details["findings"] = findings
    return base_details

def _extract_ids_from_result_url(url: str) -> dict:
    """
    Extracts environment_id, scan_id, and result_id from a Checkmarx DAST results URL.
    """
    parsed = urlparse(url)
    # Path: /applicationsAndProjects/environments/{environment_id}/{scan_id}
    path_parts = parsed.path.split('/')
    # Find the index of 'environments'
    try:
        env_idx = path_parts.index('environments')
        environment_id = path_parts[env_idx + 1]
        scan_id = path_parts[env_idx + 2]
    except (ValueError, IndexError):
        environment_id = None
        scan_id = None

    # Get resultId from query string
    query_params = parse_qs(parsed.query)
    result_id = query_params.get('resultId', [None])[0]

    return {
        "environment_id": environment_id,
        "scan_id": scan_id,
        "result_id": result_id
    }

# TODO: Change the TEST prefix to a proper variable
def get_vuln_details(input_scan_id : str, input_vuln_ids: list[str], scan_type: str, input_package_name : str, input_urls: list[str] = [""]):
    """
    Main entry point for vulnerability details extraction.
    """
    # ------------- JIRA AUTOMATION PAYLOAD TESTING VARIABLES ----------------- #

    # SCAN_ID = "0b14a69a-a6db-470c-ae75-190a45446859"
    # VULN_IDS = ["ysTAGGDe/mRAJty/2BEXEUhNeTo=", "vzScTbh1eOqrHi4fGJ7GnfgjVRg="]
    # PACKAGE_NAME = "libc-bin:2.36-9+deb12u10" #"multer 1.4.5-lts.2"
    
    SCAN_ID = input_scan_id
    VULN_IDS = input_vuln_ids
    PACKAGE_NAME = input_package_name
    
    # DAST
    # RESULTS_URL = [
    #     'https://eu-2.ast.checkmarx.net/applicationsAndProjects/environments/685226be-f5bb-4134-8175-bb6b3ff2d8a7/1b5b040b-f8ba-4927-827f-3b63d4d2452a?resultId=2bbf6cd9e29c747c3234569298a051ee2c70fbbf20646faaf33b5da279644749',
    #     'https://eu-2.ast.checkmarx.net/applicationsAndProjects/environments/685226be-f5bb-4134-8175-bb6b3ff2d8a7/1b5b040b-f8ba-4927-827f-3b63d4d2452a?resultId=2d37be733dbc95e121f16b7960e75f5d543cefba7c0bc5a026e65881059e0191&tableConfig=%7B%22search%22%3A%7B%22text%22%3A%22%22%7D%2C%22sorting%22%3A%7B%22columnKey%22%3A%22severity%22%2C%22order%22%3A%22descend%22%7D%2C%22filters%22%3A%7B%22state%22%3A%5B%22To+Verify%22%2C%22Proposed+Not+Exploitable%22%2C%22Urgent%22%2C%22Confirmed%22%5D%7D%2C%22pagination%22%3A%7B%22pageSize%22%3A10%2C%22currentPage%22%3A1%7D%2C%22grouping%22%3A%7B%22groups%22%3A%5B%5D%2C%22groupsState%22%3A%5B%5D%7D%7D'
    # ]
    RESULTS_URL = input_urls

    SCAN_TYPE_SAST = "SAST"
    SCAN_TYPE_SCA = "SCA"
    SCAN_TYPE_CSEC = "CSEC"
    SCAN_TYPE_DAST = "DAST"

    # scan_type = SCAN_TYPE  

    # ------------- JIRA AUTOMATION PAYLOAD TESTING VARIABLES ----------------- #

    log = Logger("appsec_triage")
    access_token_manager = AccessTokenManager(logger=log)
    access_token = access_token_manager.get_valid_token()
    cx_api_actions = CxApiActions(access_token=access_token, logger=log)
    helper = HelperFunctions()

    base_result_details = {
        "lbu": None,
        "scan_engine": scan_type,
        "scan_id": None,
        "project_name": None,   # used in SAST/SCA
        "branch_name": None,    # used in SAST
        "repo_url": None,       # used in SAST
        "env_name": None,       # used in DAST
        "vulnerability": [],    # SAST
        "package": [],          # SCA / CSEC
        "findings": []          # DAST
    }

    if scan_type == SCAN_TYPE_DAST:

        result_ids = []
        for result in RESULTS_URL:
            ids = _extract_ids_from_result_url(result)

            # Check if the scan id provided by the user is the same ast he scan IDs from the URLs
            if SCAN_ID == ids.get('scan_id'):
                result_ids.append({
                    "environment_id": ids.get('environment_id'),
                    "scan_id": ids.get('scan_id'),
                    "result_id": ids.get('result_id')
                })

        if len(result_ids) == 0:
            log.error("No scan ID matches with url")
            raise TypeError("No scan ID matches with url (DAST details insufficient)")
        
        env_id = result_ids[0].get('environment_id')
        env_info = cx_api_actions.get_dast_env_info(env_id)
        if env_info is None:
            log.error(f"Environment ID {env_id} is empty or does not exist")
            raise TypeError(f"Environment ID {env_id} is empty or does not exist (DAST details insufficient)")
        
        env_name = env_info.get('domain')
        scan_id = result_ids[0].get('scan_id')
        tenant_url = cx_api_actions.get_tenant_url()
        lbu_name = helper.get_lbu_name_simple(env_name)

        log.info(f"Environment Name: {env_name}")
        log.info(f"Scan ID: {scan_id}")
        log.info(f"LBU: {lbu_name}")

        # Fill only relevant fields
        base_result_details.update({
            "lbu": lbu_name,
            "env_name": env_name,
            "scan_id": scan_id
        })
        
        dast_scan_result = []
        for result in result_ids:
            result_info = cx_api_actions.get_dast_scan_result_detailed_info(result.get('result_id'), result.get('scan_id'))
            dast_scan_result.append(result_info)

        dast_findings_info = _set_dast_finding_details(base_result_details, dast_scan_result, TEST_RESULTS_URL)

        # print(json.dumps(dast_findings_info, indent=4))
        return dast_findings_info

    else:
        # Non-DAST scans
        scan_details = cx_api_actions.get_scan_details(SCAN_ID)
        if scan_details is None:
            log.error(f"Scan ID {SCAN_ID} is empty or does not exist")
            raise TypeError(f"Scan ID {SCAN_ID} is empty or does not exist (details insufficient)")

        project_name = scan_details.get('projectName')
        project_id = scan_details.get('projectId')
        branch = scan_details.get('branch')
        scan_id = scan_details.get('id')
        tenant_url = cx_api_actions.get_tenant_url()
        repo_url = helper.get_nested(scan_details, ['metadata', 'Handler', 'GitHandler', 'repo_url'])
        lbu_name = helper.get_lbu_name_simple(project_name)

        log.info(f"Project Name: {project_name}")
        log.info(f"Scan ID: {scan_id}")
        log.info(f"Branch: {branch}")
        log.info(f"LBU: {lbu_name}")

        # Fill only relevant fields
        base_result_details.update({
            "lbu": lbu_name,
            "project_name": project_name,
            "branch_name": branch,
            "scan_id": scan_id,
            "repo_url": repo_url
        })

        if scan_type == SCAN_TYPE_SAST:

            log.info(f"Scan Type: {scan_type}")

            # Batch query all vuln IDs in one API call
            selected_scan_details = {
                "project_id": project_id,
                "scan_id": scan_id,
                "branch": branch
            }

            sast = cx_api_actions.get_sast_results(scan_id, VULN_IDS)
            if sast is None:
                raise TypeError("SAST results API returned None (SAST details insufficient)")
            sast_results = sast.get("results")

            if not sast_results:
                log.warning("No SAST results for the provided vulnerability IDs")
                raise TypeError("No SAST results for the provided vulnerability IDs (SAST details insufficient)")
            else:
                sast_vuln_info = []
                for result in sast_results:
                    vuln_id = result.get("resultHash")
                    query_id = result.get("queryID")

                    sast_result_url = _assemble_sast_scan_url(tenant_url, selected_scan_details, vuln_id)
                    query_details = cx_api_actions.get_query_descriptions(scan_id, query_id)
                    if query_details is None:
                        raise TypeError(f"Query descriptions API returned None for scan_id {scan_id}, query_id {query_id} (SAST details insufficient)")

                    selected_sast_result = {
                        "severity": result.get("severity"),
                        "state": result.get("state"),
                        "status": result.get("status"),
                        "attack_vector": []
                    }

                    for node in result.get("nodes", []):
                        selected_vector_details = {
                            'branch': branch,
                            'file_path': node.get("fileName"),
                            'line_number': node.get("line"),
                            'column': node.get("column")
                        }

                        vector_url = _assemble_sast_attack_vector_url(repo_url, selected_vector_details)
                        node_vector = {
                            "name": node.get("name"),
                            "vector_url": vector_url,
                            "method": node.get("method"),
                        }

                        selected_sast_result['attack_vector'].append(node_vector)

                    sast_vuln_info = _set_sast_vulnerabilities_details(base_result_details, sast_result_url, selected_sast_result, query_details, vuln_id)

                # print(json.dumps(sast_vuln_info, indent=4))
                return sast_vuln_info

        elif scan_type == SCAN_TYPE_SCA:

            log.info(f"Scan Type: {scan_type}")

            print(PACKAGE_NAME)
            if PACKAGE_NAME is None:
                raise TypeError("NO SCA Package found or insufficient data")
            package, version = _set_package_and_version(PACKAGE_NAME)

            sca = cx_api_actions.get_sca_vulnerability_details_graphql(scan_id, project_id, package, version)
            if sca is None:
                raise TypeError("No SCA vulnerability details found or insufficient data")
            sca_vuln_info = _set_sca_package_details(base_result_details, sca)
            return sca_vuln_info

        elif scan_type == SCAN_TYPE_CSEC:
            log.info(f"Scan Type: {scan_type}")
            
            images = cx_api_actions.get_image_id_graphql(scan_id, project_id)
            if images is None:
                raise TypeError("CSEC image ID API returned None (CSEC details insufficient)")
            image = helper.get_nested(images, ['data', 'images', 'items'])
            if len(image) == 0:
                raise TypeError("CSEC image ID API returned no items (CSEC details insufficient)")

            image_id = image[0].get('imageId')
            PACKAGE_NAME = _parse_package_csec(PACKAGE_NAME)

            # Get Image Vulnerabilities using Package Name
            csec_vuln_details = cx_api_actions.get_csec_vulnerability_details_graphql(scan_id, project_id, image_id, PACKAGE_NAME)
            if csec_vuln_details is None:
                raise TypeError("CSEC vulnerability details API returned None (CSEC details insufficient)")
            image_vuln_details = helper.get_nested(csec_vuln_details, ['data', 'imagesVulnerabilities', 'items'])
            if image_vuln_details is None or not image_vuln_details or not image_vuln_details[0]:
                raise TypeError("No CSEC image vulnerability details found or insufficient data")
            risk_list = helper.get_nested(image_vuln_details[0], ['aggregatedRisks', 'risksList'])
            if risk_list is None:
                raise TypeError("No CSEC risk list found or insufficient data")

            # Get CVE Details
            cve_list = []
            for risk in risk_list:
                cve_id = risk.get("cve")
                cve_details = cx_api_actions.get_vulnerability_details(cve_id)
                if cve_details is None:
                    raise TypeError(f"CVE details API returned None for cve_id {cve_id} (CSEC details insufficient)")
                cve_list.append(cve_details)

            # Get remediations/recommendations
            layers_details = cx_api_actions.get_csec_image_layer_graphql(scan_id, project_id, image_id)
            if layers_details is None:
                raise TypeError("CSEC image layer API returned None (CSEC details insufficient)")
            layer_images = helper.get_nested(layers_details,  ['data', 'imageLayers', 'fromImages'])
            if layer_images is None:
                raise TypeError("No CSEC image layer images found or insufficient data")

            image_layers = [layer_image.get('imageName') for layer_image in layer_images] + [image_id]

            compiled_image_remediations = []
            for image_layer in image_layers:
                image_remediations = cx_api_actions.get_csec_image_remediations_graphql(scan_id, project_id, image_layer)
                if image_remediations is None:
                    raise TypeError(f"CSEC image remediations API returned None for image_layer {image_layer} (CSEC details insufficient)")
                image_remediation = helper.get_nested(image_remediations, ['data', 'imageRemediations'])
                if image_remediation is None:
                    raise TypeError(f"No CSEC image remediation found for image_layer {image_layer} (CSEC details insufficient)")
                formatted_image_remediation = _assemble_csec_image_remediations(image_remediation)
                compiled_image_remediations.append(formatted_image_remediation)

            csec_vuln_info = _set_csec_package_details(base_result_details, image_id, image_vuln_details, cve_list, compiled_image_remediations)

            if not csec_vuln_info.get("package"):
                raise TypeError("No CSEC vulnerability details found or insufficient data")

            return csec_vuln_info

        else:
            log.warning(f"The {scan_type} Scan type is not supported by this workflow automation.")

# if __name__ == "__main__":
#     main()
